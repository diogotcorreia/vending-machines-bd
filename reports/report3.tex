\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=2cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório BD - Entrega 3 - 2021/2022},
  pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{8}}
\lhead{Relatório Entrega 3 BD 2021/2022 LEIC-A}
\cfoot{Diogo Gaspar (99207), Diogo Correia (99211) e Tomás Esteves (99341)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}
\newcommand{\op}{\text}

\newlist{constraintsList}{itemize}{4}
\setlist[constraintsList]{itemsep=1pt, topsep=1pt, label=\protect\mpbullet}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}
% https://stackoverflow.com/questions/1116266/listings-in-latex-with-utf-8-or-at-least-german-umlauts
\lstset{%
        inputencoding=utf8,
        extendedchars=true,
        literate=%
        {é}{{\'{e}}}1
        {è}{{\`{e}}}1
        {ê}{{\^{e}}}1
        {ë}{{\¨{e}}}1
        {É}{{\'{E}}}1
        {Ê}{{\^{E}}}1
        {û}{{\^{u}}}1
        {ù}{{\`{u}}}1
        {ú}{{\'{u}}}1
        {â}{{\^{a}}}1
        {à}{{\`{a}}}1
        {á}{{\'{a}}}1
        {ã}{{\~{a}}}1
        {Á}{{\'{A}}}1
        {Â}{{\^{A}}}1
        {Ã}{{\~{A}}}1
        {ç}{{\c{c}}}1
        {Ç}{{\c{C}}}1
        {õ}{{\~{o}}}1
        {ó}{{\'{o}}}1
        {ô}{{\^{o}}}1
        {Õ}{{\~{O}}}1
        {Ó}{{\'{O}}}1
        {Ô}{{\^{O}}}1
        {î}{{\^{i}}}1
        {Î}{{\^{I}}}1
        {í}{{\'{i}}}1
        {Í}{{\~{Í}}}1
}

\begin{document}
\begin{titlepage}
  \begin{center}
    \vspace*{5cm}

    \Huge
    \textbf{Projeto BD - Parte 3}

    \vspace{0.5cm}
    \LARGE
    Grupo 008 | Turno L20 | LEIC-A

    \vspace{0.5cm}
    \large
    Prof. João Aparício | Prof. Leonardo Alexandre

    \vfill
  \end{center}
  \large
  \begin{itemize}
    \item[] \textbf{Diogo Gaspar} (99207) - 33\% - Xh
    \item[] \textbf{Diogo Correia} (99211) - 34\% - Xh
    \item[] \textbf{Tomás Esteves} (99341) - 33\% - Xh
  \end{itemize}
\end{titlepage}

Note-se que, ao ler o enunciado, foi entendido que as secções
\textbf{Base de Dados - Carregamento}, \textbf{Restrições de Integridade},
\textbf{SQL}, \textbf{Vistas} e \textbf{Consultas OLAP} fazem parte da estrutura
do arquivo submetido para avaliação, e não do relatório. Assim sendo, não serão aqui
incluídos os trechos de código relativos a essas secções, encontrando-se nos
respetivos ficheiros (nomeados conforme especificado pelo enunciado). Essas
secções poderão, contudo, ser incluídas no presente relatório como espaço para
esclarecimento de opções que foram tomadas ao elaborar o projeto.

\section*{Base de Dados}

\subsection*{Esquema}

% TODO: integrity constraints aren't done yet

\lstinputlisting[language=SQL]{sql/report3/schema/entities.sql}

Algumas das restrições de integridade, \texttt{RI-REn}, representadas no esquema
e que requeriam mais que um \texttt{CHECK} (\textit{triggers}, por exemplo), foram
incluídas no ficheiro \texttt{ICs.sql}, \textbf{abaixo} das restrições de integridade
da segunda secção do enunciado. Restrições resolvidas via \texttt{CHECK} e
\texttt{UNIQUE} foram, claro, incluídas no trecho acima (e em \texttt{schema.sql}).

\section*{Restrições de Integridade}

O trecho de código correspondente a esta secção encontra-se, no arquivo submetido,
em \texttt{ICs.sql}. Pretende-se realçar que, ao ler o enunciado, a interpretação
entendida por \textit{"uma categoria não pode estar contida em si própria"}, para
a primeira restrição de integridade, foi que \textbf{não podem haver ciclos na
  hierarquia da categoria}, e o respetivo \textit{trigger} foi criado de acordo
com essa interpretação. É, portanto, uma restrição que abrange mais do que
a \textit{"inclusão direta"} de categorias.

\section*{Vistas}

O trecho de código correspondente a esta secção encontra-se, no arquivo submetido,
em \texttt{view.sql}. O enunciado não foi excelente quanto a esta secção (por vários motivos).
É referido que todos os eventos de reposição correspondem a saídas de \textit{stock} de uma
quantidade de produto da \textbf{IVM}, e que os \textit{instantes} da venda
deviam ser obtidos a partir da relação \textbf{Evento de Reposição}. Assim sendo,
foi assumido, apesar de não parecer fazer muito sentido, que os eventos de reposição
se davam no mesmo instante da venda. O utilizador pode visualizar as vendas guardadas
na base de dados, na aplicação, ao clicar no botão \texttt{Past Sales}, no menu principal.

\section*{Aplicação}

A aplicação \textit{web} desenvolvida no contexto do projeto pode ser encontrada
em \url{https://ivm.gaspa.pt}, apresentando uma arquitetura bastante sucinta.
Abordando inicialmente pormenores mais \textit{low-level}, temos que todos os arquivos
\texttt{Python} e \texttt{HTML} que compõem a aplicação estão na pasta \texttt{web}.
O \textit{hub} principal da aplicação é o ficheiro \texttt{web/proj.cgi}, a partir do qual
é feito o \textit{routing} entre as diversas páginas da aplicação.

Optámos por uma abordagem \textbf{"em \textit{runtime}"}, ao invés de ter várias \textit{templates}
pré-feitas: visto que a vasta maioria das páginas que se pretende que a aplicação
apresente correspondem a \textit{queries}, tomou-se a liberdade de criar uma
\textbf{\textit{template} base} para qualquer \textit{query}, \texttt{web/templates/query.html}.

A \textit{template} tem vários componentes que são dinamicamente substituídos
pelos dados referentes ao pedido feito pelo utilizador. O \textbf{menu principal},
igualmente simples, encontra-se em \texttt{web/templates/index.html}. Possui um
leque de botões correspondentes às consultas mais básicas da aplicação que um
utilizador poderá tentar realizar: \texttt{SELECT * FROM x}, onde \texttt{x} corresponde a qualquer
uma das relações mencionadas no esquema relacional. Existe, contudo, uma \textbf{exceção}:
esta abordagem mais simples para a secção das categorias não permitia que
super/sub categorias pudessem ser corretamente criadas, pelo que para essas secções
optou-se por uma implementação \textit{"à mão"}, mais singular.

Nas páginas referentes às consultas principais da aplicação,
o utilizador pode optar por adicionar elementos à base de dados: tem total
liberdade, por exemplo, para adicionar uma \textbf{IVM} à base de dados,
havendo para tal um campo de \textit{input} que lhe permite adicionar todos os
campos referentes à relação em questão.

Note-se que toda esta simplicidade é atingida através da função \texttt{exec\_query},
presente em \texttt{web/proj.cgi}: um \textit{wrapper} que recebe uma qualquer
\textit{query} e a executa, retornando a página que a aplicação deve apresentar
ao utilizador. \textbf{Todas as \textit{queries} que passam por \texttt{exec\_query} são,
  por definição, atómicas}, já que o \textit{commit} (\texttt{dbConn.commit()}, do \texttt{psycopg})
da \textit{transaction} só ocorre depois do \textit{outcome} da \textit{query}
ser retornado. Desta forma, é garantido o \textit{rollback} das ações caso alguma
ação falhe durante o decorrer da \textit{query}.

\vspace*{0.5cm}

Pretendia-se, quanto à aplicação, que esta permitisse ao utilizador realizar um conjunto
de ações pré-determinado (garantindo a atomicidade de todas elas):


\begin{enumerate}
  \item \textbf{Inserir e remover Categorias e Sub-Categorias.}

        Para \textbf{inserir} ou \textbf{remover} uma \textbf{Categoria} ou \textbf{Sub-Categoria}
        da base de dados, o utilizador, partindo do menu principal, deve selecionar
        uma das opções (\texttt{Category} ou \texttt{Simple Category}), conforme o tipo
        que pretenda inserir ou remover. De seguida:

        \begin{enumerate}
          \item O utilizador consegue inserir uma nova \textbf{Categoria} ou \textbf{Sub-Categoria}, partindo
                do menu principal, ao clicar em qualquer um dos botões entre \textbf{Category},
                \texttt{Simple Category} ou \texttt{Super Category} - cada uma destas secções
                tem, no canto superior direito da respetiva página, um botão \texttt{Insert Category}, onde se pode
                introduzir o \textbf{nome} da categoria a inserir na base de dados. Note-se que,
                pela natureza da relação \textbf{Categoria}, todas as categorias são consideradas
                \textbf{Simples} aquando da sua inserção inicial na base de dados. Pode ainda, caso deseje,
                escolher uma das categorias existentes na base de dados para ser a sua
                \textit{\texttt{Parent Category}}.

          \item Caso pretenda remover uma \textbf{Categoria} ou \textbf{Sub-Categoria},
                o processo é ligeiramente diferente. É apresentada uma tabela ao utilizador,
                tanto na secção \texttt{Category} como em \texttt{Simple Category} e \texttt{Super Category}, onde o utilizador
                pode decidir remover a categoria em questão da base de dados.
        \end{enumerate}

  \item \textbf{Inserir e remover um Retalhista, com todas as suas responsabilidades
          de reposição de produtos.}

        \textbf{Inserir} e \textbf{remover} um \textbf{Retalhista} é em tudo semelhante ao processo
        descrito acima para as \textbf{Categorias}: o utilizador deve navegar,
        partindo do menu principal, para a secção \texttt{Retailer}, onde lhe é
        apresentada uma tabela, contendo todos os \textbf{Retalhistas} presentes na
        base de dados, e um botão para adicionar um novo \textbf{Retalhista}:

        \begin{enumerate}
          \item Caso pretenda inserir um novo \textbf{Retalhista}, o utilizador
                deve clicar no botão \texttt{Insert Retailer}, inserindo de seguida os respetivos
                \texttt{name} e \texttt{tin}.

          \item Caso pretenda remover um \textbf{Retalhista}, o utilizador deve, tal
                como nas secções referentes às \textbf{Categorias}, escolher a entrada na
                tabela correspondente ao \textbf{Retalhista} que pretende remover e clicar
                no botão \texttt{Remove} que lhe corresponde. Todas as responsabilidades
                de reposição de produtos associadas ao \textbf{Retalhista} são, claro, removidas.
        \end{enumerate}

        Note-se que, na implementação atual, \textbf{não é permitida a remoção de Retalhistas
          com Eventos de Reposição a eles associados}: se tal acontecesse, os \textbf{Eventos
          de Reposição} seriam também removidos, e o histórico de eventos não seria, assim,
        totalmente fidedigno.

  \item \textbf{Listar todos os Eventos de Reposição de uma IVM, apresentando
          o número de unidades repostas por Categoria de Produto.}

        O utilizador deve, nesta situação, navegar até à secção \texttt{IVM},
        partindo do menu principal. É-lhe apresentada uma tabela contendo todas as
        \textbf{IVM} presentes na base de dados, e cada entrada tem um botão
        associado, \texttt{List Replenishment Events}, que permite ao utilizador
        visualizar todos os eventos de reposição associados à \textbf{IVM} em questão
        sob a forma de uma tabela.

        O utilizador pode, ainda, visualizar o número
        de unidades por \textbf{Categoria} de \textbf{Produto}: ao longo da tabela,
        vão ocorrendo entradas com apenas duas colunas preenchidas, o \textbf{nome
          da Categoria} e o \textbf{número de unidades repostas (total)}.

  \item \textbf{Listar todas as Sub-Categorias de uma Super-Categoria, a todos
          os níveis de profundidade.}

        O utilizador deve, aqui, navegar até à secção \texttt{Super Category},
        partindo do menu principal. É-lhe apresentada uma tabela contendo todas as
        \textbf{Super-Categorias} presentes na base de dados, e cada entrada tem um
        botão associado, \texttt{List Sub-Categories}, que permite ao utilizador
        visualizar todas as \textbf{Sub-Categorias} associadas à \textbf{Super-Categoria}
        em questão sob a forma de uma tabela.

        Note-se que, por simplicidade, tomou-se a liberdade de não introduzir indentação
        à hierarquia das categorias: todas as categorias apresentadas são
        \textbf{Sub-Categorias} da \textbf{Super-Categoria} pretendida, não havendo diferenciação
        entre o \textit{"nível"} de profundidade a que cada \textbf{Sub-Categoria} se encontra.

\end{enumerate}

% TODO: verificar se está tudo atómico e SQL Injection proof

\section*{Consultas OLAP}

O trecho de código correspondente a esta secção encontra-se, no arquivo submetido,
em \texttt{analytics.sql}. Ao ler o enunciado, foi entendido por \textit{"escreva
  duas consultas SQL que (...)"} que as consultas OLAP em questão não precisariam
de ter \textit{botões} ou mecanismos semelhantes presentes na aplicação por
definição - precisariam apenas de estar \textit{escritas} em \texttt{analytics.sql} -
pelo que tais mecanismos não foram incluídos.

\section*{Índices}

Foi pedido, ainda, que se indicasse (justificando) os índices que faria sentido
criar, por forma a \textit{agilizar} a execução de cada uma das \textit{queries}
apresentadas de seguida. Note-se que o enunciado é particularmente confuso nesta
secção: é referido que os alunos devem supor que não existem índices nas tabelas,
"além daqueles implícitos ao declarar chaves primárias e estrangeiras". Ora, \textbf{a
  criação de chaves estrangeiras não implica indexação automática} (sem declaração
direta do programador, portanto), tal como referido na
\href{https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK}
{documentação do PostgreSQL}:

\begin{quote}
  \textit{"A foreign key must reference columns that either are a primary key or form a unique
    constraint. This means that the referenced columns always have an index (the one
    underlying the primary key or unique constraint); so checks on whether a referencing
    row has a match will be efficient. Since a DELETE of a row from the referenced
    table or an UPDATE of a referenced column will require a scan of the referencing
    table for rows matching the old value, it is often a good idea to index the referencing
    columns too. Because this is not always needed, and there are many choices available
    on how to index, declaration of a foreign key constraint does not automatically
    create an index on the referencing columns."}
\end{quote}

Considerou-se, assim, que se tratava de um lapso do enunciado (ou porventura de uma
frase construída de forma infeliz), e a respetiva indexação foi adicionada quando necessário.

\subsection*{Primeira \textit{query}:}

\lstinputlisting[language=SQL]{sql/report3/queries/example1.sql}

Para a primeira \textit{query}, optou-se por criar índices em dois atributos da relação \texttt{responsible\_for}:
\texttt{tin} e \texttt{cat\_name}.

\vspace*{0.25cm}

\begin{itemize}
  \item Não se criou nenhum índice quanto ao atributo \texttt{name}, em \texttt{retailer},
        apesar de ser o atributo \textbf{selecionado} pela \textit{query} \textbf{e ser
          \texttt{DISTINCT}} - o atributo já é \texttt{UNIQUE}, pelo
        esquema relacional, pelo que esta indexação é feita por definição (com
        \textbf{BTree}), sem ser necessário adicionar outros índices;

  \item No atributo \texttt{tin}, em \texttt{responsible\_for}, faz sentido adicionar um
        índice \textbf{BTree}: vamos realizar comparações com a chave primária \texttt{tin},
        de \texttt{Retailer}, indexada com índices \textbf{BTree}, pelo que para maximizar
        o desempenho (via \textit{Merge Join}), é esta a indexação que faz sentido;

  \item No atributo \texttt{cat\_name}, em \texttt{responsible\_for}, faz sentido adicionar
        um índice \textbf{Hash}: quer-se comparar o atributo em questão com \textit{algo}
        concreto, pelo que a comparação em $O(1)$ é ideal.
\end{itemize}

O trecho de código correspondente à indexação pretendida encontra-se abaixo:

\lstinputlisting[language=SQL]{sql/report3/indexes/index1.sql}

Note-se que a criação dos índices está ordenada segundo a mesma tal e qual a
ordenação das condições no \textit{statement} \texttt{WHERE}, para otimizar o desempenho
da \textit{query}. % justificar melhor

\subsection*{Segunda \textit{query}:}

\lstinputlisting[language=SQL]{sql/report3/queries/example2.sql}

Para a segunda \textit{query}, optou-se por criar três índices: dois na relação
\texttt{product}, nos seus atributos \texttt{category} e \texttt{description},
e outro na relação \texttt{has\_category} (em \texttt{name}).

\vspace*{0.25cm}

\begin{itemize}
  \item a
  \item b
  \item c
        % TODO: escrever coisas
\end{itemize}

O trecho de código correspondente à indexação pretendida encontra-se abaixo:

\lstinputlisting[language=SQL]{sql/report3/indexes/index2.sql}

Escolheu-se criar os índices pela ordem acima apresentada: primeiro os índice associado
aos atributos presentes em \texttt{WHERE}, e só de seguida o índice associado
a \texttt{GROUP BY}, por forma a maximizar o desempenho da \textit{query}.

% justificação melhor kek

\end{document}
